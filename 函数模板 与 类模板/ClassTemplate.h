#pragma once
#include <iostream>

/*
 * =======================================================================
 * 类模板 Box 和模板特化示例
 * =======================================================================
 *
 * 1. 类模板 Box：
 *    类模板用于定义一个泛型类，它可以处理不同类型的对象。在此代码中，`Box` 类用于封装一个内容（`content`），
 *    并提供对该内容的访问和修改方法。类模板通过类型参数 `T` 实现泛型，使得它能够接受任意类型的 `content`。
 *
 * 2. 模板特化：
 *    模板特化允许我们为特定类型提供自定义实现。本示例中，`Box<int>` 是 `Box` 类模板的一个特化，
 *    它专门处理 `int` 类型的 `content`，并在构造时输出一条特定消息。这样，模板特化可以在特定类型下定制行为。
 *
 * 优点：
 * - **灵活性**：通过模板，可以在代码中重用泛型类，而模板特化使得对某些类型提供自定义实现变得容易。
 * - **类型安全**：模板提供了类型安全，避免了需要为不同类型写多个类的重复代码。
 * - **扩展性**：新的类型可以通过简单地添加模板特化来扩展，不需要修改原有的代码。
 *
 * 缺点：
 * - **代码膨胀**：模板特化和模板实例化可能会导致编译时生成大量代码，增加编译时间和最终可执行文件的体积。
 * - **调试复杂**：模板代码在编译时生成，调试时错误信息可能较难理解，尤其是涉及复杂模板时。
 * - **模板特化的维护**：对于每个新类型，都需要编写特化版本，可能导致额外的维护工作。
 * =======================================================================
 */

 // 泛型类 Box，用于封装任意类型的内容
template<typename T>
class Box
{
private:
    T content;  // 内容，类型由 T 指定
public:
    // 构造函数，初始化 content
    Box(T content) : content(content) {}

    // 获取内容的方法
    T getContent() const
    {
        return content;
    }

    // 设置内容的方法
    void setContent(T content)
    {
        this->content = content;
    }
};

// Box 类的模板特化，专门为 int 类型提供特化版本
template<>
class Box<int>
{
private:
    int content;  // 内容类型被固定为 int
public:
    // 构造函数，初始化 content，且输出一条特定消息
    Box(int content) : content(content)
    {
        std::cout << "A的类模板特化调用";  // 当 Box<int> 被实例化时，输出特定消息
    }

    // 获取内容的方法
    int getContent() const
    {
        return content;
    }

    // 设置内容的方法
    void setContent(int content)
    {
        this->content = content;
    }
};
