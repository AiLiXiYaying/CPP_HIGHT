#pragma once
#include <iostream>

/*
 * =======================================================================
 * 函数模板 AluPrint 模板特化示例
 * =======================================================================
 *
 * 函数模板是 C++ 中的一种泛型编程方式，允许我们定义一个通用的函数模板，
 * 用于接受不同类型的参数并执行操作。模板特化可以让我们根据特定的类型
 * 定制不同的实现，提升代码的灵活性和扩展性。
 *
 * 功能：根据传入的参数类型选择合适的实现，输出不同的内容。
 *
 * 模板特化：此示例展示了函数模板的特化，特化为不同类型（如 int 和 float）提供定制的实现。
 *
 * 优点：
 * - **灵活性高**：函数模板可以用于任何类型，而模板特化则可以根据需要定制不同类型的具体实现。
 * - **代码复用**：使用模板可以避免为每种类型单独编写函数，提升代码的复用性。
 * - **提高可维护性**：增加新的类型支持时，只需要提供相应的特化版本，而无需修改其他代码。
 *
 * 缺点：
 * - **编译时开销大**：模板会在编译时生成特定的代码，导致可能较大的编译时间和代码膨胀。
 * - **模板特化需要维护多个版本**：对于每个需要特殊处理的类型，都需要提供一个模板特化版本。
 * - **调试困难**：错误信息通常较难理解，尤其是当模板使用复杂时，错误信息往往不够直观。
 *
 * =======================================================================
 */

 // 通用模板版本，接受任意类型的参数
 // 这个模板定义了如何打印传入的参数
template <typename T>
void AluPrint(T t)
{
    std::cout << "通用模板: " << t << std::endl; // 输出通用模板处理的内容
}

// 对于 int 类型的特化
// 这个模板专门处理 int 类型的参数
template <>
void AluPrint<int>(int i)
{
    std::cout << "特化模板: 整型 " << i << std::endl; // 输出特化模板处理的整型内容
}

// 对于 float 类型的特化
// 这个模板专门处理 float 类型的参数
template <>
void AluPrint<float>(float f)
{
    std::cout << "特化模板: 浮动类型 " << f << std::endl; // 输出特化模板处理的浮动类型内容
}
